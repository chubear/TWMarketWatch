<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8">
<title>報表</title>
<style>
body { 
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans CJK TC", "Microsoft JhengHei", sans-serif; 
    margin: 16px; 
}
.controls { 
    margin-bottom: 12px; 
    display:flex; 
    gap:8px; 
    align-items:center; 
    flex-wrap:wrap; 
}

table#report-table { 
    border-collapse: collapse; 
    width:100%; 
    table-layout: fixed; 
    word-wrap: break-word; 
    font-size:0.95rem; 
}
table#report-table th, table#report-table td { 
    border:1px solid #ddd; 
    padding:6px 8px; 
    vertical-align:middle; 
    text-align:center; 
}
table#report-table thead th { 
    background:#f4f6f8; 
    font-weight:600; 
    position: sticky; 
    top:0; 
    z-index:2; 
    backdrop-filter: blur(2px); 
}
table#report-table tbody tr:nth-child(even) { 
    background:#fafafa; 
}
table#report-table th:nth-child(2),
table#report-table td:nth-child(2) {
    width: 15%; /* 指標名稱欄位較大 */
}

table#report-table th:nth-child(3),
table#report-table td:nth-child(3) {
    width: 5%; /* 單位欄位較小 */
}

@media (max-width:640px) { 
    .controls { 
        flex-direction:column; 
        align-items:stretch; 
    } 
    table#report-table { 
        font-size:0.85rem; 
    } 
}
</style>
</head>
<body>

<div class="controls">
    <button id="reload">重新載入資料</button>
    <input id="api-url" type="text" value="https://api1.dottdot.com/api/reports/tw_market_watch" style="flex:1; min-width:300px; padding:4px 8px;" />
    <button id="download-csv">下載 CSV</button>
</div>

<table id="report-table" aria-live="polite">
    <thead></thead>
    <tbody><tr><td colspan="20">等待 CSV 讀取中...</td></tr></tbody>
</table>

<script>
/* 簡單 CSV 解析器（支援雙引號內含逗號與換行） */
function parseCSV(text, delimiter = ',') {
    const rows = [];
    let i = 0, len = text.length;
    let field = '', row = [], inQuotes = false;
    while (i < len) {
        const ch = text[i];
        if (inQuotes) {
            if (ch === '"') {
                if (i + 1 < len && text[i + 1] === '"') {
                    field += '"';
                    i += 2;
                } else {
                    inQuotes = false;
                    i++;
                }
            } else {
                field += ch;
                i++;
            }
        } else {
            if (ch === '"') {
                inQuotes = true;
                i++;
            } else if (ch === delimiter) {
                row.push(field);
                field = '';
                i++;
            } else if (ch === '\r') {
                i++;
            } else if (ch === '\n') {
                row.push(field);
                rows.push(row);
                row = [];
                field = '';
                i++;
            } else {
                field += ch;
                i++;
            }
        }
    }
    if (field !== '' || inQuotes || row.length > 0) {
        row.push(field);
        rows.push(row);
    }
    return rows;
}

function guessDelimiter(text) {
    const firstLine = (text.split(/\r?\n/)[0] || '');
    const candidates = [',',';','\t','|'];
    let best = ',', bestCount = -1;
    candidates.forEach(c => {
        const count = (firstLine.split(c).length - 1);
        if (count > bestCount) { bestCount = count; best = c; }
    });
    return best;
}

function buildTable(rows) {
    const table = document.getElementById('report-table');
    const thead = table.querySelector('thead');
    const tbody = table.querySelector('tbody');
    thead.innerHTML = '';
    tbody.innerHTML = '';
    if (!rows || rows.length === 0) {
        tbody.innerHTML = '<tr><td colspan="20">無資料。</td></tr>';
        return;
    }

    const header = rows[0];
    const trh = document.createElement('tr');
    header.forEach(h => {
        const th = document.createElement('th');
        th.textContent = h || '';
        trh.appendChild(th);
    });
    thead.appendChild(trh);

    for (let r = 1; r < rows.length; r++) {
        const row = rows[r];
        if (row.every(c => c === undefined || c === '')) continue;
        const tr = document.createElement('tr');
        row.forEach(cell => {
            const td = document.createElement('td');
            td.textContent = cell || '';
            tr.appendChild(td);
        });
        tbody.appendChild(tr);
    }
    
    if (tbody.children.length === 0) {
        tbody.innerHTML = '<tr><td colspan="' + Math.max(header.length, 1) + '">無資料列</td></tr>';
        return;
    }

    // 指定要合併的欄位名稱
    const columnsToMerge = ['類別', '類別總分'];
    
    // 找出要合併的欄位索引
    const colIndicesToMerge = columnsToMerge
        .map(colName => header.indexOf(colName))
        .filter(idx => idx !== -1);

    // Helper function to merge cells in a specific column
    function mergeCells(colIndex) {
        const allRows = Array.from(tbody.rows);
        let i = 0;
        
        while (i < allRows.length) {
            const currentRow = allRows[i];
            const currentCell = currentRow.cells[colIndex];
            if (!currentCell) {
                i++;
                continue;
            }
            
            const currentValue = currentCell.textContent;
            let mergeCount = 1;
            
            // 向下尋找相同的值
            for (let j = i + 1; j < allRows.length; j++) {
                const nextRow = allRows[j];
                const nextCell = nextRow.cells[colIndex];
                if (nextCell && nextCell.textContent === currentValue) {
                    mergeCount++;
                } else {
                    break;
                }
            }
            
            // 如果有需要合併的儲存格
            if (mergeCount > 1) {
                currentCell.rowSpan = mergeCount;
                currentCell.style.verticalAlign = 'middle';
                // 移除後續相同值的儲存格
                for (let j = i + 1; j < i + mergeCount; j++) {
                    const cellToRemove = allRows[j].cells[colIndex];
                    if (cellToRemove) {
                        cellToRemove.remove();
                    }
                }
            }
            
            i += mergeCount;
        }
    }

    // 依序合併指定的欄位（從後面往前合併，避免索引錯亂）
    colIndicesToMerge.sort((a, b) => b - a).forEach(colIdx => {
        mergeCells(colIdx);
    });
}

/* 從 API JSON 轉換成表格資料結構 */
function jsonToRows(jsonData) {
    if (!jsonData || !Array.isArray(jsonData) || jsonData.length === 0) {
        return [];
    }
    
    // 取得所有欄位名稱（從第一筆資料）
    const firstItem = jsonData[0];
    const headers = Object.keys(firstItem);
    
    // 建立表頭
    const rows = [headers];
    
    // 建立資料列
    jsonData.forEach(item => {
        const row = headers.map(header => {
            const value = item[header];
            return value !== null && value !== undefined ? String(value) : '';
        });
        rows.push(row);
    });
    
    return rows;
}

async function loadFromAPI(url) {
    try {
        const res = await fetch(url, {
            cache: "no-store",
            headers: {
                'Accept': 'application/json'
            }
        });
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const json = await res.json();
        
        // 檢查 API 回應格式
        if (json.status === 'success' && Array.isArray(json.data)) {
            const rows = jsonToRows(json.data);
            buildTable(rows);
        } else {
            throw new Error('API 回應格式不正確');
        }
    } catch (err) {
        console.error(err);
    }
}

document.getElementById('download-csv').addEventListener('click', async () => {
    const url = document.getElementById('api-url').value.trim();
    if (!url) {
        console.error('請輸入有效的 API URL');
        return;
    }

    try {
        const res = await fetch(url, {
            cache: "no-store",
            headers: {
                'Accept': 'application/json'
            }
        });
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const json = await res.json();

        if (json.status === 'success' && Array.isArray(json.data)) {
            const rows = jsonToRows(json.data);
            const csvContent = rows.map(e => e.join(",")).join("\n");
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', 'report.csv');
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        } else {
            throw new Error('API 回應格式不正確');
        }
    } catch (err) {
        console.error('下載失敗：' + err.message);
    }
});

document.getElementById('reload').addEventListener('click', () => {
    const url = document.getElementById('api-url').value.trim();
    if (url) {
        loadFromAPI(url);
    }
});

/* 頁面載入時自動從 API 載入資料 */
window.addEventListener('load', () => {
    const url = document.getElementById('api-url').value.trim();
    if (url) {
        loadFromAPI(url);
    }
});
</script>

</body>
</html>